% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simanalyse-derive.R
\name{sma_derive}
\alias{sma_derive}
\title{Apply R code to derive new variables.}
\usage{
sma_derive(
  object = NULL,
  code,
  monitor = ".*",
  values = list(),
  path = ".",
  analysis = "analysis0000001",
  progress = FALSE,
  options = furrr::furrr_options()
)
}
\arguments{
\item{object}{An object of class (or that can be coerced to) mcmcrs, mcmcr, nlists or nlist. If set to NULL, the object is read from \code{path} instead.}

\item{code}{A string of R code to derive posterior samples for new parameters. E.g. "var = sigma^2".}

\item{monitor}{A character vector (or regular expression if a string) specifying the names of the variables in \code{object} and/or \code{code} to monitor. By default all variables are included.}

\item{values}{A named list of additional R objects to evaluate in the R expression.}

\item{path}{A string. If object is NULL, analyses results are read from that path on disk.}

\item{analysis}{If \code{path} is used, a string for the name of the folder that contains the analysis.}

\item{progress}{A flag specifying whether to print a progress bar.}

\item{options}{The future specific options to use with the workers.}
}
\value{
An object of the same class as \code{object}
}
\description{
Apply R code to derive new variables.
}
\examples{
set.seed(10L)
code <- "for(i in 1:10){x[i] ~ dnorm(0,1/variance)}"
parameters <- nlist(variance = 4)
dat <- sims::sims_simulate(code, parameters = parameters, nsims = 2)
res <- sma_analyse(dat, code,
  code.add = "variance ~ dunif(0,10)",
  mode = sma_set_mode("quick"), monitor = "variance"
)
sma_derive(res, "sd=sqrt(variance)")
sma_derive(parameters, "sd=sqrt(variance)")

# set.seed(10L)
# code <- "for(i in 1:T){x[i] ~ dbinom(p[i],n[i])}"
# constants = list(T=10, n=rep(30, 10))
# parameters = list(p=rep(0.8, 10))
# dat  <- sims::sims_simulate(code, constants=constants, parameters = parameters, nsims=2)
# dat_outlier <- sma_derive(dat, "y = c(x[1:4], 1, x[6:10])", monitor=c("n","T","y"))
# res <- sma_analyse(dat_outlier, sub("x\\[", "y\\[", code),
# code.add = "for(i in 1:T){p[i] = p.const}
#             p.const ~ dunif(0,1)",
# mode=sma_set_mode("quick"), monitor="p.const")
# sma_derive(res, "odds=p.const/(1-p.const)", monitor="odds")
# sma_derive(parameters, "odds=p[1]/(1-p[1])", monitor="odds")
}
